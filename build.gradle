import java.text.SimpleDateFormat

apply from: rootProject.file("versions.gradle")

allprojects {
    group = "com.r3.conclave"
    version = conclave_graal_version
}

ext {
    // Global variables
    graalRevision = getGraalRevision()
    versionType = getVersionType(version)

    logger.info("Graal revision: $graalRevision")
    logger.info("Conclave Graal revision: $version, type: $versionType")

    // Directories and files paths
    tempDir = "${rootProject.buildDir}/tmp"
    graalDir = "$tempDir/graal"

    // The build process implemented here works by cloning a specific version of graalvm into the build directory of
    // this project, patching it, then building it using its native build system. Ideally, we'd use the repository
    // directory itself as the input/output for gradle tasks, but this won't work. Gradle will detect changes to the
    // content of the directory and determine that the task is "not up to date", thereby breaking incremental builds,
    // see https://docs.gradle.org/current/userguide/more_about_tasks.html for more information.
    // By using dummy files in place of the repository directory, we avoid this problem. The dummy files contain the
    // date and time of the last time the associated built task was run.
    graalCloneDummy = "$tempDir/graal_cloned_time"
    graalPatchDummy = "$tempDir/graal_patched_time"
    graalBuildDummy = "$tempDir/graal_built_time"
}

// There is no clean task in the root build.gradle, so here we add one
// If we don't do this, build/tmp will not be cleaned.
tasks.register('clean', Delete) {
    delete rootProject.buildDir
}

task cloneGraal(type: Exec) {

    // Task details
    group = 'Other'
    description = 'Clone a specific version of Graal. Delete existing graal clone if present.'

    def cloneScript = "${rootProject.projectDir}/scripts/cloneGraal.sh"

    // Re-run this only if the version or commit ID have changed.
    inputs.property('graalVersion', graal_version)
    inputs.property('graalCommitID', graal_commit_id)
    inputs.file(cloneScript)

    // Depends on output of cloneGraal task
    // See comment above for more information on dummy files
    outputs.file(graalCloneDummy)

    doFirst {
        mkdir tempDir
        workingDir tempDir
        commandLine "$cloneScript", "$graal_version", "$graal_commit_id"
    }

    doLast {
        // Write current date-time to dummy file. If this task is run again, the content of this file
        // will change and subsequent tasks will re-run.
        writeDateToFile(graalCloneDummy)
    }
}

task patchGraal(type: Exec) {
    dependsOn(cloneGraal)

    // Task details
    group = 'Other'
    description = 'Patch the graal repository with Conclave specific changes.'

    def patchScript = "${rootProject.projectDir}/scripts/patchGraal.sh"
    def patchFile = "${rootProject.projectDir}/patches/graal.patch"

    // Depends on output of cloneGraal task
    // See comment above for more information on dummy files
    inputs.files(patchScript, patchFile, graalCloneDummy)
    outputs.file(graalPatchDummy)

    doFirst {
        mkdir tempDir
        workingDir tempDir
        commandLine "$patchScript"
    }

    doLast {
        // Write current date-time to dummy file. If this task is run again, the content of this file
        // will change and subsequent tasks will re-run.
        writeDateToFile(graalPatchDummy)
    }
}

subprojects {
    apply plugin: 'maven-publish'  // Plugin to publish artifacts to a maven repo
    apply plugin: 'signing'
    apply plugin: 'java'

    signing {
        // Signing is required for the publication of releases to Maven Central.
        // As per Gradle Signing Plugin rules, "required = false" means that the artifacts
        //   will only be signed if signatory credentials are configured (i.e. only in TeamCity).
        //   The build will skip signing if the key is not available, which is what we want for local builds
        required = false
        def key = System.getenv("CONCLAVE_PUBLICATION_SIGNING_PRIVATE_KEY")
        def password = System.getenv("CONCLAVE_PUBLICATION_SIGNING_PRIVATE_KEY_PASSWORD")
        useInMemoryPgpKeys(key, password)
        sign(project.publishing.publications)
    }

    publishing {
        publications {
            maven(MavenPublication) {
                addPomDetails(pom, project.name, getProjectDescription(project.name))
            }
        }

        // List of repositories where the artifact is published
        repositories {

            // Artifactory repository
            maven {
                name = "artifactory"
                url = getArtifactoryForPublication()
                credentials {
                    username = System.getenv("CONCLAVE_ARTIFACTORY_USERNAME")
                    password = System.getenv("CONCLAVE_ARTIFACTORY_PASSWORD")
                }
            }

            // Local repository - Useful for testing purposes
            maven {
                name = "build"
                url = "$buildDir/repo"
            }

            //  This repository is used for publishing to Maven Central from TeamCity.
            if (versionType == VersionType.GA_RELEASE) {
                maven {
                    name = "OSSRH"
                    url = "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2"
                    credentials {
                        username = System.getenv("CONCLAVE_OSSRH_USERNAME")
                        password = System.getenv("CONCLAVE_OSSRH_PASSWORD")
                    }
                }
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper functions
////////////////////////////////////////////////////////////////////////////////////////////////////
String getArtifactoryForPublication() {
    String mavenRepo
    if (conclave_graal_version.endsWith("-SNAPSHOT")) {
        mavenRepo = "conclave-maven-dev"
    } else if (conclave_graal_version.matches(/.+\-RC[0-9]+$/)) {
        mavenRepo = "conclave-maven-unstable"
    } else {
        mavenRepo = "conclave-maven-stable"
    }
    return "https://software.r3.com/artifactory/" + mavenRepo
}

// Writes the current date and time to a file
static def writeDateToFile(String fileName) {
    new File(fileName).text = "${new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())}\n"
}

// Ensure that a given task is being run inside the provided container by throwing an exception
// if that is not the case.
static def assertDockerContainerIsBeingUsed() {

    if (System.getenv("DOCKER_CONTAINER_IS_RUNNING") != "TRUE") {
        String message = "It was detected that the task is not being run inside the provided docker container.\n" +
                "This might lead to unexpected errors if your system is not properly configured.\n" +
                "Please consider running the task inside the provided docker container by running the script ./scripts/devenv_shell.sh first"

        throw new GradleException(message)
    }
}


static def getProjectDescription(String projectName) {

    if (projectName == "graal-sdk") {
        return 'Graal SDK'
    } else if (projectName == "graalvm") {
        return 'Graal VM'
    } else {
        throw new IllegalArgumentException("Developer error, wrong project name given as input. Project name: $projectName")
    }
}

static def addPomDetails(MavenPom pom, String name, String description) {
    pom.name = name
    pom.description = description
    pom.url = "https://github.com/R3Conclave/graal-patches"

    //  Licenses for the POM sections are added in the build.gradle files of the subprojects

    pom.developers {
        developer {
            name = 'Conclave Team'
            email = "conclave@r3.com"
            organization = 'R3 LLC'
            organizationUrl = "https://www.r3.com"
        }
    }
    pom.scm {
        connection = "scm:git:git://github.com/R3Conclave/graal-patches.git"
        developerConnection = "scm:git:ssh://github.com:R3Conclave/graal-patches.git"
        url = "https://github.com/R3Conclave/graal-patches/tree/master"
    }
}

enum VersionType {
    GA_RELEASE,
    RELEASE_CANDIDATE,
    SNAPSHOT
}

static def getVersionType(String version) {
    VersionType versionType

    if (version.endsWith("-SNAPSHOT")) {
        versionType = VersionType.SNAPSHOT
    } else if (version.matches(/.+\-RC[0-9]+$/)) {
        versionType = VersionType.RELEASE_CANDIDATE
    } else {
        versionType = VersionType.GA_RELEASE
    }
    return versionType
}

String getGraalRevision() {
    String graalRevision

    try {
        // Get the id of the last commit from the current branch
        graalRevision = "git rev-parse HEAD".execute().text.trim()
    } catch (Exception ignored) {
        logger.warn("Unable to get conclave revision. Git is unavailable in build environment")
        graalRevision = "unknown"
    }

    return graalRevision
}
